/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

/*---------------------------------------------------------------------*/
/* TO DO LIST / BUGS TO FIX 										   */
/*-----------------------------------------------------------------------

[BUG]	Local variables for IF statement (Now they are initialized as
		global ones)
		
[BUG] 	Check if variables exists before assignment
	  	(Ia = 10; is allowed even without INT Ia = 1; before)
	  	
[?] 	Disallow overriding existing variables with declaration of
		variable of the same name

[TO DO] While statement

[TO DO] Functions
 
---------------------------------------------------------------------*/

PARSER_BEGIN(parsername)
import java.util.*;

public class parsername
{
  public static void main(String args []) throws ParseException
  {
    parsername parser = new parsername(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Enter an expression like \"1+(2+3)*4 XXDD;\" :");
      try
      {
        Map<String,Object> map=new HashMap<String,Object>(); 
        switch (parsername.multipleLines(map))
        {
          case 0 : 
          System.out.println("OK. End of program");
          break;
          case 1 : 
          System.out.println("Goodbye.");
          break;
          default : 
          break;
        }
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        parsername.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
}

PARSER_END(parsername)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* OPERATORS */
{
  < PLUS     : "+" >
| < MINUS    : "-" >
| < MULTIPLY : "*" >
| < DIVIDE   : "/" >
}

TOKEN :
{
  < INTEGER : (< DIGIT >)+ >
| < FLOAT   : (< DIGIT >)+"."(< DIGIT >)+>
| < #DIGIT  : [ "0"-"9" ] >
| < VARNAME : < LETTER >(< LETTER >|< DIGIT >)* >
| < LETTER  : [ "a"-"z" ] > 
}


/*
If LETTER is not below VARNAME, VARNAMEs with just 1 letter are
treated as LETTER and result in errors
*/

TOKEN: /* DATA TYPES */
{
  < INT_VARNAME   : "I" <VARNAME> > 
| < BOOL_VARNAME  : "B" <VARNAME> > 
| < FLOAT_VARNAME : "F" <VARNAME> > 
}

/*---------------------------------------------------------------------*/
/* DECLARE VARIABLES
/* We allow only simple initializations by values
/* No statements allowed here
/*---------------------------------------------------------------------*/

void declareINT(Map map, boolean execute):
{String a;}
{
    "INT" < INT_VARNAME > {a = token.toString();} "="
    <INTEGER> {if(execute){map.put(a, Integer.parseInt(token.image));}}
    (","  < INT_VARNAME > {a = token.toString();} "="
    <INTEGER> {if(execute){map.put(a, Integer.parseInt(token.image));}})* ";"
}

void declareBOOL(Map map, boolean execute):
{String a;}
{
  "BOOLEAN" < BOOL_VARNAME > {a = token.toString();} "="
  ("TRUE" | "FALSE") {if(execute){map.put(a, Boolean.parseBoolean(token.image)); }}
  ("," 		< BOOL_VARNAME > {a = token.toString();} "="
  ("TRUE" | "FALSE") {if(execute){map.put(a, Boolean.parseBoolean(token.image));}})* ";"
}

void declareFLOAT(Map map, boolean execute):
{String a;}
{
  "FLOAT" < FLOAT_VARNAME > {a = token.toString();} "="
  <FLOAT> {if(execute){map.put(a, Double.parseDouble(token.image));}}
  (","    < FLOAT_VARNAME > {a = token.toString();} "="
  <FLOAT> {if(execute){map.put(a, Double.parseDouble(token.image));}})* ";"
}

/*---------------------------------------------------------------------*/
/* SINGLE/MULTIPLE LINES STATS HERE*/
/*---------------------------------------------------------------------*/

int multipleLines(Map map):
{boolean a; int b;}
{ 
  (line(map, true))* "END" {return 0;}
| ";"
  {
    return 1;
  }
}

void line(Map map, boolean execute) :
{boolean a; int b; double c; Token s;}
{
/*	Boolean value can be return either by boolean statement
	or by any type of comparison, so we basically allow sth like:
	Bb = EQB TRUE FALSE; 											*/

  
  LOOKAHEAD(3)
  s = < BOOL_VARNAME > "=" (a = booleanStatement(map) | a = comparison(map)) ";" 
  {
    if(!execute){return;}
    System.out.println("Result: " + a);
    map.replace(s.toString(), a);
    return;
  }
| LOOKAHEAD(3)
  s = < INT_VARNAME > "=" b = integerStatement(map) ";" 
  {
    if(!execute){return;}
    System.out.println("Result: " + b);
    map.replace(s.toString(), b);
    return;
  }
| s = < FLOAT_VARNAME > "=" c = floatStatement(map) ";" 
  {
    if(!execute){return;}
    System.out.println("Result: " + c);
    map.replace(s.toString(), c);
    return;
  }
| declareINT(map, execute)   	{System.out.println("Variable(s) declared: " + execute); return;}
| declareFLOAT(map, execute) 	{System.out.println("Variable(s) declared: " + execute); return;}
| declareBOOL(map, execute)  	{System.out.println("Variable(s) declared: " + execute); return;}
| ifStatement(map)				{System.out.println("If statement executed"); return;}
}

/*---------------------------------------------------------------------*/
/*INTEGER ARITHMETIC STATS HERE*/
/*---------------------------------------------------------------------*/

int integerStatement(Map map) :
{int a, b;}
{
  a = aterm(map)
  ( < PLUS >   b = aterm(map) {a += b; } | < MINUS >  b = aterm(map) {a -= b; } )*
  {return a; }
}

int aterm(Map map) :
{int a, b;}
{
  a = asubterm(map)
  ( < MULTIPLY > b = asubterm(map) {a *= b; }| < DIVIDE > b = asubterm(map) {a /= b; } )*
  {return a; }
}

int asubterm(Map map) :
{int a;}
{
  < MINUS > a = abase(map) {return -a;} | a = abase(map) {return a;}
}

int abase(Map map) :
{int a;}
{
  (
    < INTEGER > {a = Integer.parseInt(token.image);} | "(" a=integerStatement(map) ")"
  | < INT_VARNAME > {a = (Integer) map.get(token.toString());}
  ){return a;}
}

/*---------------------------------------------------------------------*/
/*BOOLEAN ARITHMETIC STATS HERE*/
/*---------------------------------------------------------------------*/

boolean booleanStatement(Map map) :
{boolean a,b;}
{
  a = bterm(map)
  ( "OR"  b = bterm(map) {a = a || b; } )*
  { return a;}
}

boolean bterm(Map map) :
{boolean a, b;}
{
  a = bsubterm(map)
  ( "AND" b = bsubterm(map) {a = a && b;} )*
  {return a;}
}

boolean bsubterm(Map map) :
{boolean a;}
{
  "NOT" a = bbase(map) {return !a;} | a = bbase(map) {return a;}
}

boolean bbase(Map map) :
{boolean a;}
{
  (
  "TRUE" {a = Boolean.parseBoolean(token.image);} |
  "FALSE" {a = Boolean.parseBoolean(token.image);} |
  "(" a=booleanStatement(map) ")" |
  < BOOL_VARNAME > {a = (Boolean) map.get(token.toString());}
  ){return a;}
}

/*---------------------------------------------------------------------*/
/*FLOAT ARITHMETIC STATS HERE*/
/*---------------------------------------------------------------------*/

double floatStatement(Map map) :
{double a, b;}
{
  a = fterm(map)
  ( < PLUS >   b = fterm(map) {a += b; } | < MINUS >  b = fterm(map) {a -= b; } )*
  {return a;}
}

double fterm(Map map) :
{double a, b;}
{
  a = fsubterm(map)
  ( < MULTIPLY > b = fsubterm(map) {a *= b; }| < DIVIDE > b = fsubterm(map) {a /= b; } )*
  {return a;}
}

double fsubterm(Map map) :
{double a;}
{
  < MINUS > a = fbase(map) {return -a;} | a = fbase(map) {return a;}
}

double fbase(Map map) :
{double a;}
{
  (
    < FLOAT > {a = Double.parseDouble(token.image);} | "(" a=floatStatement(map) ")"
  | < FLOAT_VARNAME > {a = (double) map.get(token.toString());}
  )
  {return a;}
}

/*---------------------------------------------------------------------*/
/*COMPARISON STATEMENTS STATS HERE*/
/*---------------------------------------------------------------------*/

boolean comparison(Map map) :
{boolean a;}
{
	(a = booleanComparison(map) | a = integerComparison(map) | a = floatComparison(map))
	{return a;}
}

boolean booleanComparison(Map map) :
{boolean a, b;}
{
	"EQB"  a = booleanStatement(map) b = booleanStatement(map) {return a == b;}
|	"NEQB" a = booleanStatement(map) b = booleanStatement(map) {return a != b;} 
}

boolean integerComparison(Map map) :
{int a, b;}
{
	"EQI"  a = integerStatement(map) b = integerStatement(map) {return a == b;}
|	"NEQI" a = integerStatement(map) b = integerStatement(map) {return a != b;}
|	"GEI"  a = integerStatement(map) b = integerStatement(map) {return a >= b;}
|	"LEI"  a = integerStatement(map) b = integerStatement(map) {return a <= b;}
|	"GI"   a = integerStatement(map) b = integerStatement(map) {return a > b;}
|	"LI"   a = integerStatement(map) b = integerStatement(map) {return a < b;}
}

boolean floatComparison(Map map) :
{double a, b;}
{
	"EQF"  a = floatStatement(map) b = floatStatement(map) {return a == b;}
|	"NEQF" a = floatStatement(map) b = floatStatement(map) {return a != b;}
|	"GEF"  a = floatStatement(map) b = floatStatement(map) {return a >= b;}
|	"LEF"  a = floatStatement(map) b = floatStatement(map) {return a <= b;}
|	"GF"   a = floatStatement(map) b = floatStatement(map) {return a > b;}
|	"LF"   a = floatStatement(map) b = floatStatement(map) {return a < b;}
}

/*---------------------------------------------------------------------*/
/*IF STATEMENT STATS HERE*/
/*---------------------------------------------------------------------*/

void ifStatement(Map map) :
{boolean execute = false; boolean done = false;}
{ 
  	//Develop local variables later
  	
	"IF" (execute = comparison(map) | execute = booleanStatement(map))
	{done = execute; System.out.println("\nIf executed: " + execute);}
	"THEN" (line(map, execute))*
	(
	  "ELSEIF" (execute = comparison(map) | execute = booleanStatement(map))
	  {execute = execute && !done; done = done || execute; System.out.println("Elseif executed: " + execute);}	  
	  "THEN" (line(map, execute))*
	)*
	(("ELSE" "THEN" (line(map, !done))* {System.out.println("Else executed: " + !done);} "ENDIF") | "ENDIF")
}


